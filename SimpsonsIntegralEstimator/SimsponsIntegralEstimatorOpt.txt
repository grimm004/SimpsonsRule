; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25507.1 

include listing.inc

INCLUDELIB OLDNAMES

; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25507.1 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CL@DOLGJJCA@i?3?5?$CFu?7n?3?5?$CFu?7Tn?3?5?$CF?420f?7Mn?3?5?$CF?420f?7@ ; `string'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
EXTRN	__imp_?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAHXZ:PROC
EXTRN	__imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__security_check_cookie:PROC
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
PUBLIC	__@@_PchSym_@00@UfhvihUnzcLtirnnvggUwlxfnvmghUtrgsfyUhrnkhlmhifovUhrnkhlmhrmgvtizovhgrnzgliUcGEUivovzhvUhgwzucOlyq@4B2008FD98C1DD4
;	COMDAT __@@_PchSym_@00@UfhvihUnzcLtirnnvggUwlxfnvmghUtrgsfyUhrnkhlmhifovUhrnkhlmhrmgvtizovhgrnzgliUcGEUivovzhvUhgwzucOlyq@4B2008FD98C1DD4
_BSS	SEGMENT
__@@_PchSym_@00@UfhvihUnzcLtirnnvggUwlxfnvmghUtrgsfyUhrnkhlmhifovUhrnkhlmhrmgvtizovhgrnzgliUcGEUivovzhvUhgwzucOlyq@4B2008FD98C1DD4 DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CL@DOLGJJCA@i?3?5?$CFu?7n?3?5?$CFu?7Tn?3?5?$CF?420f?7Mn?3?5?$CF?420f?7@
CONST	SEGMENT
??_C@_0CL@DOLGJJCA@i?3?5?$CFu?7n?3?5?$CFu?7Tn?3?5?$CF?420f?7Mn?3?5?$CF?420f?7@ DB 'i'
	DB	': %u', 09H, 'n: %u', 09H, 'Tn: %.20f', 09H, 'Mn: %.20f', 09H, 'S'
	DB	'n: %.20f', 0aH, 00H				; `string'
CONST	ENDS
PUBLIC	printf
PUBLIC	_vfprintf_l
PUBLIC	__local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	??$pow@HFX@@YANHF@Z				; pow<int,short,void>
PUBLIC	main
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4008000000000000
PUBLIC	__real@4010000000000000
PUBLIC	__real@4020000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@4044000000000000
EXTRN	log:PROC
EXTRN	pow:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN8@printf
	DD	imagerel $LN8@printf+85
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4@vfprintf_l
	DD	imagerel $LN4@vfprintf_l+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN45
	DD	imagerel $LN45+572
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?m@@YANJNN@Z DD imagerel ?m@@YANJNN@Z
	DD	imagerel ?m@@YANJNN@Z+61
	DD	imagerel $unwind$?m@@YANJNN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?m@@YANJNN@Z DD imagerel ?m@@YANJNN@Z+61
	DD	imagerel ?m@@YANJNN@Z+216
	DD	imagerel $chain$4$?m@@YANJNN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?m@@YANJNN@Z DD imagerel ?m@@YANJNN@Z+216
	DD	imagerel ?m@@YANJNN@Z+249
	DD	imagerel $chain$5$?m@@YANJNN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?t@@YANJNN@Z DD imagerel ?t@@YANJNN@Z
	DD	imagerel ?t@@YANJNN@Z+101
	DD	imagerel $unwind$?t@@YANJNN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?t@@YANJNN@Z DD imagerel ?t@@YANJNN@Z+101
	DD	imagerel ?t@@YANJNN@Z+178
	DD	imagerel $chain$0$?t@@YANJNN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?t@@YANJNN@Z DD imagerel ?t@@YANJNN@Z+178
	DD	imagerel ?t@@YANJNN@Z+342
	DD	imagerel $chain$1$?t@@YANJNN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?f@@YANN@Z DD imagerel ?f@@YANN@Z
	DD	imagerel ?f@@YANN@Z+69
	DD	imagerel $unwind$?f@@YANN@Z
pdata	ENDS
;	COMDAT __real@4044000000000000
CONST	SEGMENT
__real@4044000000000000 DQ 04044000000000000r	; 40
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@4020000000000000
CONST	SEGMENT
__real@4020000000000000 DQ 04020000000000000r	; 8
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?f@@YANN@Z DD 030901H
	DD	026809H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?t@@YANJNN@Z DD 021H
	DD	imagerel ?t@@YANJNN@Z
	DD	imagerel ?t@@YANJNN@Z+101
	DD	imagerel $unwind$?t@@YANJNN@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?t@@YANJNN@Z DD 020421H
	DD	0123404H
	DD	imagerel ?t@@YANJNN@Z
	DD	imagerel ?t@@YANJNN@Z+101
	DD	imagerel $unwind$?t@@YANJNN@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?t@@YANJNN@Z DD 0105501H
	DD	02c855H
	DD	03b84cH
	DD	04a838H
	DD	059826H
	DD	06881dH
	DD	077815H
	DD	08680eH
	DD	013010aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?m@@YANJNN@Z DD 021H
	DD	imagerel ?m@@YANJNN@Z
	DD	imagerel ?m@@YANJNN@Z+61
	DD	imagerel $unwind$?m@@YANJNN@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?m@@YANJNN@Z DD 0a2921H
	DD	02c829H
	DD	03b81bH
	DD	04a80dH
	DD	086808H
	DD	0123404H
	DD	imagerel ?m@@YANJNN@Z
	DD	imagerel ?m@@YANJNN@Z+61
	DD	imagerel $unwind$?m@@YANJNN@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?m@@YANJNN@Z DD 082801H
	DD	059828H
	DD	068816H
	DD	07780eH
	DD	013010aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	01d5c01H
	DD	03f85cH
	DD	04e856H
	DD	05d843H
	DD	06c83dH
	DD	07b838H
	DD	08a833H
	DD	09982eH
	DD	0a8829H
	DD	0b7824H
	DD	0c681bH
	DD	01e6417H
	DD	01d5417H
	DD	01c3417H
	DD	01a0117H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 041b01H
	DD	07017521bH
	DD	030156016H
xdata	ENDS
; Function compile flags: /Ogtpy
; File f:\users\max grimmett\documents\github\simpsonsrule\simpsonsintegralestimator\simpsonsintegralestimator.cpp
;	COMDAT ?f@@YANN@Z
_TEXT	SEGMENT
x$ = 64
?f@@YANN@Z PROC						; f, COMDAT

; 10   : {

	sub	rsp, 56					; 00000038H
	movaps	XMMWORD PTR [rsp+32], xmm6
	movaps	xmm6, xmm0

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	call	log
	movaps	xmm1, xmm6
	movaps	xmm2, xmm0
	movsd	xmm0, QWORD PTR __real@4024000000000000
	mulsd	xmm1, xmm6
	addsd	xmm6, xmm6
	mulsd	xmm1, QWORD PTR __real@4008000000000000
	subsd	xmm1, xmm6

; 12   : }

	movaps	xmm6, XMMWORD PTR [rsp+32]
	addsd	xmm2, xmm1
	divsd	xmm0, xmm2
	add	rsp, 56					; 00000038H
	ret	0
?f@@YANN@Z ENDP						; f
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\max grimmett\documents\github\simpsonsrule\simpsonsintegralestimator\simpsonsintegralestimator.cpp
;	COMDAT ?t@@YANJNN@Z
_TEXT	SEGMENT
n$ = 160
start$ = 168
end$ = 176
?t@@YANJNN@Z PROC					; t, COMDAT

; 15   : {

	mov	rax, rsp
	sub	rsp, 152				; 00000098H
	movaps	XMMWORD PTR [rax-24], xmm6

; 17   : 	double total = 0;
; 18   : 	double current = start;

	movaps	xmm6, xmm1
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	xmm7, xmm2
	movaps	XMMWORD PTR [rax-56], xmm8
	subsd	xmm7, xmm1
	movaps	XMMWORD PTR [rax-72], xmm9
	xorps	xmm8, xmm8

; 19   : 	for (long i = 0; i < n - 1; i++) total += f((current += interval));

	movsd	xmm9, QWORD PTR __real@4024000000000000
	movaps	XMMWORD PTR [rax-88], xmm10
	movsd	xmm10, QWORD PTR __real@4008000000000000
	movd	xmm0, ecx
	dec	ecx
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	xmm11, xmm1
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	xmm12, xmm2
	cvtdq2pd xmm0, xmm0
	divsd	xmm7, xmm0
	test	ecx, ecx
	jle	SHORT $LN3@t

; 16   : 	double interval = (end - start) / n;

	mov	QWORD PTR [rax-8], rbx
	mov	ebx, ecx
	npad	5
$LL14@t:

; 19   : 	for (long i = 0; i < n - 1; i++) total += f((current += interval));

	addsd	xmm6, xmm7

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	movaps	xmm0, xmm6
	call	log
	movaps	xmm1, xmm6
	movaps	xmm2, xmm6
	mulsd	xmm2, xmm6
	addsd	xmm1, xmm6
	mulsd	xmm2, xmm10
	subsd	xmm2, xmm1
	movaps	xmm1, xmm9
	addsd	xmm0, xmm2
	divsd	xmm1, xmm0

; 19   : 	for (long i = 0; i < n - 1; i++) total += f((current += interval));

	addsd	xmm8, xmm1
	sub	rbx, 1
	jne	SHORT $LL14@t
	mov	rbx, QWORD PTR [rsp+144]
$LN3@t:

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	movaps	xmm0, xmm11
	call	log
	movaps	xmm1, xmm11
	movaps	xmm6, xmm9
	mulsd	xmm1, xmm11
	addsd	xmm11, xmm11
	mulsd	xmm1, xmm10
	subsd	xmm1, xmm11
	addsd	xmm0, xmm1
	divsd	xmm6, xmm0
	movaps	xmm0, xmm12
	call	log
	movaps	xmm1, xmm12

; 21   : }

	lea	r11, QWORD PTR [rsp+152]
	movaps	xmm11, XMMWORD PTR [r11-104]
	addsd	xmm8, xmm8

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	mulsd	xmm1, xmm12
	addsd	xmm12, xmm12
	mulsd	xmm1, xmm10

; 21   : }

	movaps	xmm10, XMMWORD PTR [r11-88]

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	subsd	xmm1, xmm12

; 21   : }

	movaps	xmm12, XMMWORD PTR [r11-120]

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	addsd	xmm0, xmm1
	divsd	xmm9, xmm0

; 20   : 	return (interval * (f(start) + f(end) + (2 * total))) / 2;

	addsd	xmm6, xmm9

; 21   : }

	movaps	xmm9, XMMWORD PTR [r11-72]
	addsd	xmm6, xmm8
	movaps	xmm8, XMMWORD PTR [r11-56]
	mulsd	xmm6, xmm7
	movaps	xmm7, XMMWORD PTR [rsp+112]
	mulsd	xmm6, QWORD PTR __real@3fe0000000000000
	movaps	xmm0, xmm6
	movaps	xmm6, XMMWORD PTR [r11-24]
	mov	rsp, r11
	ret	0
?t@@YANJNN@Z ENDP					; t
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\max grimmett\documents\github\simpsonsrule\simpsonsintegralestimator\simpsonsintegralestimator.cpp
;	COMDAT ?m@@YANJNN@Z
_TEXT	SEGMENT
n$ = 160
start$ = 168
end$ = 176
?m@@YANJNN@Z PROC					; m, COMDAT

; 24   : {

	mov	rax, rsp
	sub	rsp, 152				; 00000098H
	movaps	XMMWORD PTR [rax-40], xmm7
	xorps	xmm7, xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	xmm8, xmm2
	movd	xmm0, ecx

; 25   : 	double interval = (end - start) / n;

	subsd	xmm8, xmm1
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	xmm9, xmm1
	cvtdq2pd xmm0, xmm0
	divsd	xmm8, xmm0

; 26   : 	double total = 0;
; 27   : 	double current = start;
; 28   : 	for (long i = 0; i < n; i++) total += f((current + (current += interval)) / 2);

	test	ecx, ecx
	jle	$LN3@m

; 25   : 	double interval = (end - start) / n;

	mov	QWORD PTR [rax-8], rbx
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-88], xmm10
	movsd	xmm10, QWORD PTR __real@3fe0000000000000
	movaps	XMMWORD PTR [rax-104], xmm11
	movsd	xmm11, QWORD PTR __real@4008000000000000
	movaps	XMMWORD PTR [rax-120], xmm12
	movsd	xmm12, QWORD PTR __real@4024000000000000
	mov	ebx, ecx
$LL10@m:

; 26   : 	double total = 0;
; 27   : 	double current = start;
; 28   : 	for (long i = 0; i < n; i++) total += f((current + (current += interval)) / 2);

	addsd	xmm9, xmm8
	movaps	xmm6, xmm9
	addsd	xmm6, xmm9
	mulsd	xmm6, xmm10

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	movaps	xmm0, xmm6
	call	log
	movaps	xmm1, xmm6
	mulsd	xmm1, xmm6
	addsd	xmm6, xmm6
	mulsd	xmm1, xmm11
	subsd	xmm1, xmm6
	addsd	xmm0, xmm1
	movaps	xmm1, xmm12
	divsd	xmm1, xmm0

; 26   : 	double total = 0;
; 27   : 	double current = start;
; 28   : 	for (long i = 0; i < n; i++) total += f((current + (current += interval)) / 2);

	addsd	xmm7, xmm1
	sub	rbx, 1
	jne	SHORT $LL10@m
	movaps	xmm12, XMMWORD PTR [rsp+32]
	movaps	xmm11, XMMWORD PTR [rsp+48]
	movaps	xmm10, XMMWORD PTR [rsp+64]
	movaps	xmm6, XMMWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [rsp+144]
$LN3@m:

; 29   : 	return interval * total;
; 30   : }

	movaps	xmm9, XMMWORD PTR [rsp+80]
	mulsd	xmm7, xmm8
	movaps	xmm8, XMMWORD PTR [rsp+96]
	movaps	xmm0, xmm7
	movaps	xmm7, XMMWORD PTR [rsp+112]
	add	rsp, 152				; 00000098H
	ret	0
?m@@YANJNN@Z ENDP					; m
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\max grimmett\documents\github\simpsonsrule\simpsonsintegralestimator\simpsonsintegralestimator.cpp
;	COMDAT ?s@@YANNN@Z
_TEXT	SEGMENT
tn$ = 8
mn$ = 16
?s@@YANNN@Z PROC					; s, COMDAT

; 34   : 	return (tn + (2 * mn)) / 3;

	addsd	xmm1, xmm1
	addsd	xmm1, xmm0
	divsd	xmm1, QWORD PTR __real@4008000000000000
	movaps	xmm0, xmm1

; 35   : }

	ret	0
?s@@YANNN@Z ENDP					; s
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\max grimmett\documents\github\simpsonsrule\simpsonsintegralestimator\simpsonsintegralestimator.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xtgmath.h
; File f:\users\max grimmett\documents\github\simpsonsrule\simpsonsintegralestimator\simpsonsintegralestimator.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xtgmath.h
; File f:\users\max grimmett\documents\github\simpsonsrule\simpsonsintegralestimator\simpsonsintegralestimator.cpp
;	COMDAT main
_TEXT	SEGMENT
main	PROC						; COMDAT

; 38   : {

$LN45:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	sub	rsp, 208				; 000000d0H
	movaps	XMMWORD PTR [rax-24], xmm6

; 39   : 	for (short i = 30; i < 40; i++)

	mov	esi, 30
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+80], xmm13

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	movsd	xmm13, QWORD PTR __real@4000000000000000
	movaps	xmm0, xmm13
	movaps	XMMWORD PTR [rsp+64], xmm14
	movaps	XMMWORD PTR [rsp+48], xmm15
	call	log
	addsd	xmm0, QWORD PTR __real@4020000000000000
	movsd	xmm12, QWORD PTR __real@4024000000000000
	movaps	xmm15, xmm12
	divsd	xmm15, xmm0
	movsd	xmm0, QWORD PTR __real@4010000000000000
	call	log
	addsd	xmm0, QWORD PTR __real@4044000000000000
	movsd	xmm11, QWORD PTR __real@4008000000000000
	movaps	xmm1, xmm12
	movsd	xmm14, QWORD PTR __real@3fe0000000000000
	divsd	xmm1, xmm0
	addsd	xmm15, xmm1
	npad	1
$LL4@main:

; 41   : 		long n = (long)pow(2, i);

	movsx	ebp, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xtgmath.h

; 70   : 	return (_CSTD pow(static_cast<type>(_Left), static_cast<type>(_Right)));

	movaps	xmm0, xmm13
	movd	xmm1, ebp
	cvtdq2pd xmm1, xmm1
	call	pow
; File f:\users\max grimmett\documents\github\simpsonsrule\simpsonsintegralestimator\simpsonsintegralestimator.cpp

; 41   : 		long n = (long)pow(2, i);

	cvttsd2si edi, xmm0

; 16   : 	double interval = (end - start) / n;

	movaps	xmm10, xmm13
	xorps	xmm7, xmm7

; 17   : 	double total = 0;
; 18   : 	double current = start;

	movaps	xmm6, xmm13
	movd	xmm1, edi

; 19   : 	for (long i = 0; i < n - 1; i++) total += f((current += interval));

	lea	eax, DWORD PTR [rdi-1]
	cvtdq2pd xmm1, xmm1
	divsd	xmm10, xmm1
	test	eax, eax
	jle	SHORT $LN10@main
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xtgmath.h

; 70   : 	return (_CSTD pow(static_cast<type>(_Left), static_cast<type>(_Right)));

	mov	ebx, eax
	npad	7
$LL34@main:
; File f:\users\max grimmett\documents\github\simpsonsrule\simpsonsintegralestimator\simpsonsintegralestimator.cpp

; 19   : 	for (long i = 0; i < n - 1; i++) total += f((current += interval));

	addsd	xmm6, xmm10

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	movaps	xmm0, xmm6
	call	log
	movaps	xmm1, xmm6
	movaps	xmm2, xmm6
	mulsd	xmm2, xmm6
	addsd	xmm1, xmm6
	mulsd	xmm2, xmm11
	subsd	xmm2, xmm1
	movaps	xmm1, xmm12
	addsd	xmm0, xmm2
	divsd	xmm1, xmm0

; 19   : 	for (long i = 0; i < n - 1; i++) total += f((current += interval));

	addsd	xmm7, xmm1
	sub	rbx, 1
	jne	SHORT $LL34@main
$LN10@main:

; 20   : 	return (interval * (f(start) + f(end) + (2 * total))) / 2;

	addsd	xmm7, xmm7
	xorps	xmm8, xmm8

; 27   : 	double current = start;

	movaps	xmm9, xmm13

; 20   : 	return (interval * (f(start) + f(end) + (2 * total))) / 2;

	addsd	xmm7, xmm15
	mulsd	xmm7, xmm10
	mulsd	xmm7, xmm14

; 28   : 	for (long i = 0; i < n; i++) total += f((current + (current += interval)) / 2);

	test	edi, edi
	jle	SHORT $LN21@main

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	mov	ebx, edi
	npad	5
$LL36@main:

; 28   : 	for (long i = 0; i < n; i++) total += f((current + (current += interval)) / 2);

	addsd	xmm9, xmm10
	movaps	xmm6, xmm9
	addsd	xmm6, xmm9
	mulsd	xmm6, xmm14

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	movaps	xmm0, xmm6
	call	log
	movaps	xmm1, xmm6
	mulsd	xmm1, xmm6
	addsd	xmm6, xmm6
	mulsd	xmm1, xmm11
	subsd	xmm1, xmm6
	addsd	xmm0, xmm1
	movaps	xmm1, xmm12
	divsd	xmm1, xmm0

; 28   : 	for (long i = 0; i < n; i++) total += f((current + (current += interval)) / 2);

	addsd	xmm8, xmm1
	sub	rbx, 1
	jne	SHORT $LL36@main
$LN21@main:

; 29   : 	return interval * total;

	mulsd	xmm8, xmm10

; 42   : 		int start = 2;
; 43   : 		int end = 4;
; 44   : 
; 45   : 		double tn = t(n, start, end);
; 46   : 		double mn = m(n, start, end);
; 47   : 		double sn = s(tn, mn);
; 48   : 
; 49   : 		printf("i: %u\tn: %u\tTn: %.20f\tMn: %.20f\tSn: %.20f\n", i, n, tn, mn, sn);

	lea	rcx, OFFSET FLAT:??_C@_0CL@DOLGJJCA@i?3?5?$CFu?7n?3?5?$CFu?7Tn?3?5?$CF?420f?7Mn?3?5?$CF?420f?7@
	mov	r8d, edi
	mov	edx, ebp
	movaps	xmm3, xmm7
	movq	r9, xmm3

; 34   : 	return (tn + (2 * mn)) / 3;

	movaps	xmm0, xmm8
	addsd	xmm0, xmm8
	addsd	xmm0, xmm7
	divsd	xmm0, xmm11

; 42   : 		int start = 2;
; 43   : 		int end = 4;
; 44   : 
; 45   : 		double tn = t(n, start, end);
; 46   : 		double mn = m(n, start, end);
; 47   : 		double sn = s(tn, mn);
; 48   : 
; 49   : 		printf("i: %u\tn: %u\tTn: %.20f\tMn: %.20f\tSn: %.20f\n", i, n, tn, mn, sn);

	movsd	QWORD PTR [rsp+40], xmm0
	movsd	QWORD PTR [rsp+32], xmm8
	call	printf
	inc	si
	cmp	si, 40					; 00000028H
	jl	$LL4@main

; 50   : 	}
; 51   : 
; 52   : 	std::cin.get();

	mov	rcx, QWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
	call	QWORD PTR __imp_?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAHXZ

; 53   : 
; 54   : 	return 0;
; 55   : }

	movaps	xmm14, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+208]
	mov	rbx, QWORD PTR [r11+16]
	xor	eax, eax
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+48]
	mov	rsp, r11
	pop	rdi
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xtgmath.h
;	COMDAT ??$pow@HFX@@YANHF@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$ = 16
??$pow@HFX@@YANHF@Z PROC				; pow<int,short,void>, COMDAT

; 69   : 	typedef _STD _Common_float_type_t<_Ty1, _Ty2> type;
; 70   : 	return (_CSTD pow(static_cast<type>(_Left), static_cast<type>(_Right)));

	movsd	xmm0, QWORD PTR __real@4000000000000000
	movsx	eax, dx
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	jmp	pow
??$pow@HFX@@YANHF@Z ENDP				; pow<int,short,void>
_TEXT	ENDS
END
END
