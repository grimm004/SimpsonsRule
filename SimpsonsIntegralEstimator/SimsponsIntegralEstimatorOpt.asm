; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25507.1 

include listing.inc

INCLUDELIB OLDNAMES

; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25507.1 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CF@OICLFPHE@n?3?5?$CFu?7Tn?3?5?$CF?420f?7Mn?3?5?$CF?420f?7Sn?3?5?$CF?4@ ; `string'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
EXTRN	__imp_?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAHXZ:PROC
EXTRN	__imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___std_terminate:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp___CxxFrameHandler3:PROC
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
PUBLIC	__@@_PchSym_@00@UfhvihUnzcLtirnnvggUwlxfnvmghUtrgsfyUhrnkhlmhifovUhrnkhlmhrmgvtizovhgrnzgliUcGEUivovzhvUhgwzucOlyq@4B2008FD98C1DD4
;	COMDAT __@@_PchSym_@00@UfhvihUnzcLtirnnvggUwlxfnvmghUtrgsfyUhrnkhlmhifovUhrnkhlmhrmgvtizovhgrnzgliUcGEUivovzhvUhgwzucOlyq@4B2008FD98C1DD4
_BSS	SEGMENT
__@@_PchSym_@00@UfhvihUnzcLtirnnvggUwlxfnvmghUtrgsfyUhrnkhlmhifovUhrnkhlmhrmgvtizovhgrnzgliUcGEUivovzhvUhgwzucOlyq@4B2008FD98C1DD4 DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CF@OICLFPHE@n?3?5?$CFu?7Tn?3?5?$CF?420f?7Mn?3?5?$CF?420f?7Sn?3?5?$CF?4@
CONST	SEGMENT
??_C@_0CF@OICLFPHE@n?3?5?$CFu?7Tn?3?5?$CF?420f?7Mn?3?5?$CF?420f?7Sn?3?5?$CF?4@ DB 'n'
	DB	': %u', 09H, 'Tn: %.20f', 09H, 'Mn: %.20f', 09H, 'Sn: %.20f', 0aH
	DB	00H						; `string'
CONST	ENDS
PUBLIC	printf
PUBLIC	_vfprintf_l
PUBLIC	__local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	main
PUBLIC	?pow@@YANNH@Z					; pow
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4008000000000000
PUBLIC	__real@4010000000000000
PUBLIC	__real@4020000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@4044000000000000
EXTRN	log:PROC
EXTRN	pow:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN8
	DD	imagerel $LN8+85
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4
	DD	imagerel $LN4+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN47
	DD	imagerel $LN47+573
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?m@@YANJNN@Z DD imagerel ?m@@YANJNN@Z
	DD	imagerel ?m@@YANJNN@Z+61
	DD	imagerel $unwind$?m@@YANJNN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?m@@YANJNN@Z DD imagerel ?m@@YANJNN@Z+61
	DD	imagerel ?m@@YANJNN@Z+216
	DD	imagerel $chain$4$?m@@YANJNN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?m@@YANJNN@Z DD imagerel ?m@@YANJNN@Z+216
	DD	imagerel ?m@@YANJNN@Z+249
	DD	imagerel $chain$5$?m@@YANJNN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?t@@YANJNN@Z DD imagerel ?t@@YANJNN@Z
	DD	imagerel ?t@@YANJNN@Z+101
	DD	imagerel $unwind$?t@@YANJNN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?t@@YANJNN@Z DD imagerel ?t@@YANJNN@Z+101
	DD	imagerel ?t@@YANJNN@Z+178
	DD	imagerel $chain$0$?t@@YANJNN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?t@@YANJNN@Z DD imagerel ?t@@YANJNN@Z+178
	DD	imagerel ?t@@YANJNN@Z+342
	DD	imagerel $chain$1$?t@@YANJNN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?f@@YANN@Z DD imagerel ?f@@YANN@Z
	DD	imagerel ?f@@YANN@Z+69
	DD	imagerel $unwind$?f@@YANN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pow@@YANNH@Z DD imagerel $LN5
	DD	imagerel $LN5+36
	DD	imagerel $unwind$?pow@@YANNH@Z
pdata	ENDS
;	COMDAT __real@4044000000000000
CONST	SEGMENT
__real@4044000000000000 DQ 04044000000000000r	; 40
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@4020000000000000
CONST	SEGMENT
__real@4020000000000000 DQ 04020000000000000r	; 8
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pow@@YANNH@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?f@@YANN@Z DD 030901H
	DD	026809H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?t@@YANJNN@Z DD 021H
	DD	imagerel ?t@@YANJNN@Z
	DD	imagerel ?t@@YANJNN@Z+101
	DD	imagerel $unwind$?t@@YANJNN@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?t@@YANJNN@Z DD 020421H
	DD	0123404H
	DD	imagerel ?t@@YANJNN@Z
	DD	imagerel ?t@@YANJNN@Z+101
	DD	imagerel $unwind$?t@@YANJNN@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?t@@YANJNN@Z DD 0105501H
	DD	02c855H
	DD	03b84cH
	DD	04a838H
	DD	059826H
	DD	06881dH
	DD	077815H
	DD	08680eH
	DD	013010aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?m@@YANJNN@Z DD 021H
	DD	imagerel ?m@@YANJNN@Z
	DD	imagerel ?m@@YANJNN@Z+61
	DD	imagerel $unwind$?m@@YANJNN@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?m@@YANJNN@Z DD 0a2921H
	DD	02c829H
	DD	03b81bH
	DD	04a80dH
	DD	086808H
	DD	0123404H
	DD	imagerel ?m@@YANJNN@Z
	DD	imagerel ?m@@YANJNN@Z+61
	DD	imagerel $unwind$?m@@YANJNN@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?m@@YANJNN@Z DD 082801H
	DD	059828H
	DD	068816H
	DD	07780eH
	DD	013010aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	01b5501H
	DD	03f855H
	DD	04e84fH
	DD	05d83cH
	DD	06c836H
	DD	07b831H
	DD	08a82cH
	DD	099827H
	DD	0a8822H
	DD	0b781dH
	DD	0c6817H
	DD	01d6413H
	DD	01c3413H
	DD	01a0113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 041b01H
	DD	07017521bH
	DD	030156016H
xdata	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\cmath
;	COMDAT ?pow@@YANNH@Z
_TEXT	SEGMENT
_Xx$ = 48
_Yx$ = 56
?pow@@YANNH@Z PROC					; pow, COMDAT

; 10   : 	{

$LN5:
	sub	rsp, 40					; 00000028H

; 11   : 	if (_Yx == 2)

	cmp	edx, 2
	jne	SHORT $LN2@pow

; 12   : 		return (_Xx * _Xx);

	mulsd	xmm0, xmm0

; 15   : 	}

	add	rsp, 40					; 00000028H
	ret	0
$LN2@pow:
	movd	xmm1, edx

; 13   : 
; 14   : 	return (_CSTD pow(_Xx, static_cast<double>(_Yx)));

	cvtdq2pd xmm1, xmm1
	call	pow

; 15   : 	}

	add	rsp, 40					; 00000028H
	ret	0
?pow@@YANNH@Z ENDP					; pow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\max grimmett\documents\github\simpsonsrule\simpsonsintegralestimator\simpsonsintegralestimator.cpp
;	COMDAT ?f@@YANN@Z
_TEXT	SEGMENT
x$ = 64
?f@@YANN@Z PROC						; f, COMDAT

; 10   : {

	sub	rsp, 56					; 00000038H
	movaps	XMMWORD PTR [rsp+32], xmm6
	movaps	xmm6, xmm0

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	call	log
	movaps	xmm1, xmm6
	movaps	xmm2, xmm0
	movsd	xmm0, QWORD PTR __real@4024000000000000
	mulsd	xmm1, xmm6
	addsd	xmm6, xmm6
	mulsd	xmm1, QWORD PTR __real@4008000000000000
	subsd	xmm1, xmm6

; 12   : }

	movaps	xmm6, XMMWORD PTR [rsp+32]
	addsd	xmm2, xmm1
	divsd	xmm0, xmm2
	add	rsp, 56					; 00000038H
	ret	0
?f@@YANN@Z ENDP						; f
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\max grimmett\documents\github\simpsonsrule\simpsonsintegralestimator\simpsonsintegralestimator.cpp
;	COMDAT ?t@@YANJNN@Z
_TEXT	SEGMENT
n$ = 160
start$ = 168
end$ = 176
?t@@YANJNN@Z PROC					; t, COMDAT

; 15   : {

	mov	rax, rsp
	sub	rsp, 152				; 00000098H
	movaps	XMMWORD PTR [rax-24], xmm6

; 17   : 	double total = 0;
; 18   : 	double current = start;

	movaps	xmm6, xmm1
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	xmm7, xmm2
	movaps	XMMWORD PTR [rax-56], xmm8
	subsd	xmm7, xmm1
	movaps	XMMWORD PTR [rax-72], xmm9
	xorps	xmm8, xmm8

; 19   : 	for (int i = 0; i < n - 1; i++) total += f((current += interval));

	movsd	xmm9, QWORD PTR __real@4024000000000000
	movaps	XMMWORD PTR [rax-88], xmm10
	movsd	xmm10, QWORD PTR __real@4008000000000000
	movd	xmm0, ecx
	dec	ecx
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	xmm11, xmm1
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	xmm12, xmm2
	cvtdq2pd xmm0, xmm0
	divsd	xmm7, xmm0
	test	ecx, ecx
	jle	SHORT $LN3@t

; 16   : 	double interval = (end - start) / n;

	mov	QWORD PTR [rax-8], rbx
	mov	ebx, ecx
	npad	5
$LL14@t:

; 19   : 	for (int i = 0; i < n - 1; i++) total += f((current += interval));

	addsd	xmm6, xmm7

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	movaps	xmm0, xmm6
	call	log
	movaps	xmm1, xmm6
	movaps	xmm2, xmm6
	mulsd	xmm2, xmm6
	addsd	xmm1, xmm6
	mulsd	xmm2, xmm10
	subsd	xmm2, xmm1
	movaps	xmm1, xmm9
	addsd	xmm0, xmm2
	divsd	xmm1, xmm0

; 19   : 	for (int i = 0; i < n - 1; i++) total += f((current += interval));

	addsd	xmm8, xmm1
	sub	rbx, 1
	jne	SHORT $LL14@t
	mov	rbx, QWORD PTR [rsp+144]
$LN3@t:

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	movaps	xmm0, xmm11
	call	log
	movaps	xmm1, xmm11
	movaps	xmm6, xmm9
	mulsd	xmm1, xmm11
	addsd	xmm11, xmm11
	mulsd	xmm1, xmm10
	subsd	xmm1, xmm11
	addsd	xmm0, xmm1
	divsd	xmm6, xmm0
	movaps	xmm0, xmm12
	call	log
	movaps	xmm1, xmm12

; 21   : }

	lea	r11, QWORD PTR [rsp+152]
	movaps	xmm11, XMMWORD PTR [r11-104]
	addsd	xmm8, xmm8

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	mulsd	xmm1, xmm12
	addsd	xmm12, xmm12
	mulsd	xmm1, xmm10

; 21   : }

	movaps	xmm10, XMMWORD PTR [r11-88]

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	subsd	xmm1, xmm12

; 21   : }

	movaps	xmm12, XMMWORD PTR [r11-120]

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	addsd	xmm0, xmm1
	divsd	xmm9, xmm0

; 20   : 	return (interval * (f(start) + f(end) + (2 * total))) / 2;

	addsd	xmm6, xmm9

; 21   : }

	movaps	xmm9, XMMWORD PTR [r11-72]
	addsd	xmm6, xmm8
	movaps	xmm8, XMMWORD PTR [r11-56]
	mulsd	xmm6, xmm7
	movaps	xmm7, XMMWORD PTR [rsp+112]
	mulsd	xmm6, QWORD PTR __real@3fe0000000000000
	movaps	xmm0, xmm6
	movaps	xmm6, XMMWORD PTR [r11-24]
	mov	rsp, r11
	ret	0
?t@@YANJNN@Z ENDP					; t
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\max grimmett\documents\github\simpsonsrule\simpsonsintegralestimator\simpsonsintegralestimator.cpp
;	COMDAT ?m@@YANJNN@Z
_TEXT	SEGMENT
n$ = 160
start$ = 168
end$ = 176
?m@@YANJNN@Z PROC					; m, COMDAT

; 24   : {

	mov	rax, rsp
	sub	rsp, 152				; 00000098H
	movaps	XMMWORD PTR [rax-40], xmm7
	xorps	xmm7, xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	xmm8, xmm2
	movd	xmm0, ecx

; 25   : 	double interval = (end - start) / n;

	subsd	xmm8, xmm1
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	xmm9, xmm1
	cvtdq2pd xmm0, xmm0
	divsd	xmm8, xmm0

; 26   : 	double total = 0;
; 27   : 	double current = start;
; 28   : 	for (int i = 0; i < n; i++) total += f((current + (current += interval)) / 2);

	test	ecx, ecx
	jle	$LN3@m

; 25   : 	double interval = (end - start) / n;

	mov	QWORD PTR [rax-8], rbx
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-88], xmm10
	movsd	xmm10, QWORD PTR __real@3fe0000000000000
	movaps	XMMWORD PTR [rax-104], xmm11
	movsd	xmm11, QWORD PTR __real@4008000000000000
	movaps	XMMWORD PTR [rax-120], xmm12
	movsd	xmm12, QWORD PTR __real@4024000000000000
	mov	ebx, ecx
$LL10@m:

; 26   : 	double total = 0;
; 27   : 	double current = start;
; 28   : 	for (int i = 0; i < n; i++) total += f((current + (current += interval)) / 2);

	addsd	xmm9, xmm8
	movaps	xmm6, xmm9
	addsd	xmm6, xmm9
	mulsd	xmm6, xmm10

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	movaps	xmm0, xmm6
	call	log
	movaps	xmm1, xmm6
	mulsd	xmm1, xmm6
	addsd	xmm6, xmm6
	mulsd	xmm1, xmm11
	subsd	xmm1, xmm6
	addsd	xmm0, xmm1
	movaps	xmm1, xmm12
	divsd	xmm1, xmm0

; 26   : 	double total = 0;
; 27   : 	double current = start;
; 28   : 	for (int i = 0; i < n; i++) total += f((current + (current += interval)) / 2);

	addsd	xmm7, xmm1
	sub	rbx, 1
	jne	SHORT $LL10@m
	movaps	xmm12, XMMWORD PTR [rsp+32]
	movaps	xmm11, XMMWORD PTR [rsp+48]
	movaps	xmm10, XMMWORD PTR [rsp+64]
	movaps	xmm6, XMMWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [rsp+144]
$LN3@m:

; 29   : 	return interval * total;
; 30   : }

	movaps	xmm9, XMMWORD PTR [rsp+80]
	mulsd	xmm7, xmm8
	movaps	xmm8, XMMWORD PTR [rsp+96]
	movaps	xmm0, xmm7
	movaps	xmm7, XMMWORD PTR [rsp+112]
	add	rsp, 152				; 00000098H
	ret	0
?m@@YANJNN@Z ENDP					; m
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\max grimmett\documents\github\simpsonsrule\simpsonsintegralestimator\simpsonsintegralestimator.cpp
;	COMDAT ?s@@YANNN@Z
_TEXT	SEGMENT
tn$ = 8
mn$ = 16
?s@@YANNN@Z PROC					; s, COMDAT

; 34   : 	return (tn + (2 * mn)) / 3;

	addsd	xmm1, xmm1
	addsd	xmm1, xmm0
	divsd	xmm1, QWORD PTR __real@4008000000000000
	movaps	xmm0, xmm1

; 35   : }

	ret	0
?s@@YANNN@Z ENDP					; s
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\max grimmett\documents\github\simpsonsrule\simpsonsintegralestimator\simpsonsintegralestimator.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\cmath
; File f:\users\max grimmett\documents\github\simpsonsrule\simpsonsintegralestimator\simpsonsintegralestimator.cpp
;	COMDAT main
_TEXT	SEGMENT
main	PROC						; COMDAT

; 38   : {

$LN47:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	push	rdi
	sub	rsp, 208				; 000000d0H
	movaps	XMMWORD PTR [rax-24], xmm6

; 39   : 	for (int i = 0; i < 30; i++)

	xor	esi, esi
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+80], xmm13

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	movsd	xmm13, QWORD PTR __real@4000000000000000
	movaps	xmm0, xmm13
	movaps	XMMWORD PTR [rsp+64], xmm14
	movaps	XMMWORD PTR [rsp+48], xmm15
	call	log
	addsd	xmm0, QWORD PTR __real@4020000000000000
	movsd	xmm12, QWORD PTR __real@4024000000000000
	movsd	xmm6, QWORD PTR __real@4010000000000000
	movaps	xmm15, xmm12
	divsd	xmm15, xmm0
	movaps	xmm0, xmm6
	call	log
	addsd	xmm0, QWORD PTR __real@4044000000000000
	movsd	xmm11, QWORD PTR __real@4008000000000000
	movaps	xmm1, xmm12
	movsd	xmm14, QWORD PTR __real@3fe0000000000000
	divsd	xmm1, xmm0
	addsd	xmm15, xmm1
	npad	5
$LL4@main:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\cmath

; 11   : 	if (_Yx == 2)

	cmp	esi, 2
	jne	SHORT $LN7@main

; 12   : 		return (_Xx * _Xx);

	movaps	xmm0, xmm6
	jmp	SHORT $LN6@main
$LN7@main:
	movd	xmm1, esi

; 13   : 
; 14   : 	return (_CSTD pow(_Xx, static_cast<double>(_Yx)));

	movaps	xmm0, xmm13
	cvtdq2pd xmm1, xmm1
	call	pow
$LN6@main:
; File f:\users\max grimmett\documents\github\simpsonsrule\simpsonsintegralestimator\simpsonsintegralestimator.cpp

; 41   : 		long n = (int)pow(2.0, i);

	cvttsd2si edi, xmm0

; 16   : 	double interval = (end - start) / n;

	movaps	xmm8, xmm13
	xorps	xmm7, xmm7

; 17   : 	double total = 0;
; 18   : 	double current = start;

	movaps	xmm6, xmm13
	movd	xmm0, edi

; 19   : 	for (int i = 0; i < n - 1; i++) total += f((current += interval));

	lea	eax, DWORD PTR [rdi-1]
	cvtdq2pd xmm0, xmm0
	divsd	xmm8, xmm0
	test	eax, eax
	jle	SHORT $LN12@main

; 41   : 		long n = (int)pow(2.0, i);

	mov	ebx, eax
$LL36@main:

; 19   : 	for (int i = 0; i < n - 1; i++) total += f((current += interval));

	addsd	xmm6, xmm8

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	movaps	xmm0, xmm6
	call	log
	movaps	xmm1, xmm6
	movaps	xmm2, xmm6
	mulsd	xmm2, xmm6
	addsd	xmm1, xmm6
	mulsd	xmm2, xmm11
	subsd	xmm2, xmm1
	movaps	xmm1, xmm12
	addsd	xmm0, xmm2
	divsd	xmm1, xmm0

; 19   : 	for (int i = 0; i < n - 1; i++) total += f((current += interval));

	addsd	xmm7, xmm1
	sub	rbx, 1
	jne	SHORT $LL36@main
$LN12@main:

; 20   : 	return (interval * (f(start) + f(end) + (2 * total))) / 2;

	addsd	xmm7, xmm7
	xorps	xmm9, xmm9

; 27   : 	double current = start;

	movaps	xmm10, xmm13

; 20   : 	return (interval * (f(start) + f(end) + (2 * total))) / 2;

	addsd	xmm7, xmm15
	mulsd	xmm7, xmm8
	mulsd	xmm7, xmm14

; 28   : 	for (int i = 0; i < n; i++) total += f((current + (current += interval)) / 2);

	test	edi, edi
	jle	SHORT $LN23@main

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	mov	ebx, edi
	npad	5
$LL38@main:

; 28   : 	for (int i = 0; i < n; i++) total += f((current + (current += interval)) / 2);

	addsd	xmm10, xmm8
	movaps	xmm6, xmm10
	addsd	xmm6, xmm10
	mulsd	xmm6, xmm14

; 11   : 	return 10 / ((3 * (x * x)) - (2 * x) + log(x));

	movaps	xmm0, xmm6
	call	log
	movaps	xmm1, xmm6
	mulsd	xmm1, xmm6
	addsd	xmm6, xmm6
	mulsd	xmm1, xmm11
	subsd	xmm1, xmm6
	addsd	xmm0, xmm1
	movaps	xmm1, xmm12
	divsd	xmm1, xmm0

; 28   : 	for (int i = 0; i < n; i++) total += f((current + (current += interval)) / 2);

	addsd	xmm9, xmm1
	sub	rbx, 1
	jne	SHORT $LL38@main
$LN23@main:

; 29   : 	return interval * total;

	mulsd	xmm9, xmm8

; 42   : 		int start = 2;
; 43   : 		int end = 4;
; 44   : 
; 45   : 		double tn = t(n, start, end);
; 46   : 		double mn = m(n, start, end);
; 47   : 		double sn = s(tn, mn);
; 48   : 
; 49   : 		printf("n: %u\tTn: %.20f\tMn: %.20f\tSn: %.20f\n", n, tn, mn, sn);

	lea	rcx, OFFSET FLAT:??_C@_0CF@OICLFPHE@n?3?5?$CFu?7Tn?3?5?$CF?420f?7Mn?3?5?$CF?420f?7Sn?3?5?$CF?4@
	mov	edx, edi
	movaps	xmm2, xmm7
	movq	r8, xmm2

; 34   : 	return (tn + (2 * mn)) / 3;

	movaps	xmm0, xmm9

; 42   : 		int start = 2;
; 43   : 		int end = 4;
; 44   : 
; 45   : 		double tn = t(n, start, end);
; 46   : 		double mn = m(n, start, end);
; 47   : 		double sn = s(tn, mn);
; 48   : 
; 49   : 		printf("n: %u\tTn: %.20f\tMn: %.20f\tSn: %.20f\n", n, tn, mn, sn);

	movaps	xmm3, xmm9

; 34   : 	return (tn + (2 * mn)) / 3;

	addsd	xmm0, xmm9

; 42   : 		int start = 2;
; 43   : 		int end = 4;
; 44   : 
; 45   : 		double tn = t(n, start, end);
; 46   : 		double mn = m(n, start, end);
; 47   : 		double sn = s(tn, mn);
; 48   : 
; 49   : 		printf("n: %u\tTn: %.20f\tMn: %.20f\tSn: %.20f\n", n, tn, mn, sn);

	movq	r9, xmm3

; 34   : 	return (tn + (2 * mn)) / 3;

	addsd	xmm0, xmm7
	divsd	xmm0, xmm11

; 42   : 		int start = 2;
; 43   : 		int end = 4;
; 44   : 
; 45   : 		double tn = t(n, start, end);
; 46   : 		double mn = m(n, start, end);
; 47   : 		double sn = s(tn, mn);
; 48   : 
; 49   : 		printf("n: %u\tTn: %.20f\tMn: %.20f\tSn: %.20f\n", n, tn, mn, sn);

	movsd	QWORD PTR [rsp+32], xmm0
	call	printf
	movsd	xmm6, QWORD PTR __real@4010000000000000
	inc	esi
	cmp	esi, 30
	jl	$LL4@main

; 50   : 	}
; 51   : 
; 52   : 	std::cin.get();

	mov	rcx, QWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
	call	QWORD PTR __imp_?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAHXZ

; 53   : 
; 54   : 	return 0;
; 55   : }

	movaps	xmm14, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+208]
	mov	rbx, QWORD PTR [r11+16]
	xor	eax, eax
	mov	rsi, QWORD PTR [r11+24]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+48]
	mov	rsp, r11
	pop	rdi
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 151  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 152  :         }

	ret	0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$dead$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 640  :     {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, rdx
	mov	rsi, rcx

; 641  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rbx
	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 642  :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Format$ = 80
printf	PROC						; COMDAT

; 952  :     {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx

; 953  :         int _Result;
; 954  :         va_list _ArgList;
; 955  :         __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]

; 956  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	rbx, rax

; 641  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 957  :         __crt_va_end(_ArgList);
; 958  :         return _Result;
; 959  :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
printf	ENDP
_TEXT	ENDS
END
END
